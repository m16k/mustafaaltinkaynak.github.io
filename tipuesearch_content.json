{"pages":[{"url":"https://www.mustafa.com.tr/pages/about.html","text":"2004 yılından bu yana siber güvenlik üzerine araştırmalarda bulundum. Çok sayıda yerli yada yabancı websitelerinde bulunan zafiyetleri ilgililere göndererek kapatılmasını sağladım. Bu siteler içerisinde ülkemizde eğitim veren üniversiteler, kurumsal firmaları, devlet kurumları sistemleri bulunmaktadır. İşimden arta kalan vakitlerimde üniversitelerde, eğitim öğretim kurumlarında, etkinliklerde siber güvenlik üzerine seminer-eğitim, sunum ve konferanslar vermekteyim. Octosec bilgi güvenliği grubu üyesiyim. Herhangi bir konuda bana iletişim sayfasından ya da linkedin profilimden ulaşabilirsiniz. Eğitmen 2017: Hacker101 - Akademik Bilişim 2017 - Aksaray 2016: Güvenlik 101 - UZEM Yazılım Kampı - Samsun 2016: Web Uygulama Güvenliği - Hacktrick'16 Güvenlik Konferansı - Eskişehir Anadolu Üniv. 2016: Web Uygulama Güvenliği - Hacker Kamp - Sakarya Üniversitesi 2016: Enine Boyuna Siber Güvenlik - Hacker Kamp - İstanbul Üniversitesi 2016: Enine Boyuna Siber Güvenlik - Akademik Bilişim 2016 - Aydın 2015: Uygulamalı Sızma Testi - İzHack 2015 - İzmir 2015: Uygulamalı Sızma Testi - OMÜ Hacker Kamp 2015 - Samsun 2015: Güvenlik 101 - UZEM Yazılım Kampı - Samsun 2015: Web Uygulama Güvenliği - Hacktrick'15 Güvenlik Konferansı - İstanbul Sunum 2015: Devlet Kurumları ve Siber Güvenlik - Hacktrick'15 Güvenlik Konferansı - İstanbul 2015: Kamu Güvenliğini Sağlamada Siber İstihbaratın Rolü - Akademik Bilişim - Aydın 2012: Sosyal Medya ve Erişim Riskleri - İlkadım TML, EML - Samsun 2011: Ağ Güvenliği ve Sızma Testleri - Ondokuz Mayıs Üniversitesi - Samsun 2011: Kullanıcı Güvenliği - Ondokuz Mayıs Üniversitesi - Samsun 2008: Web Güvenlik Semineri - Samsun Katılımcı 2015: Siber Güvenlik Kış Kampı - Kayseri 2014: Hacktrick'14 Güvenlik Konferansı 2014: Güvenlik 101 - Akademik Bilişim - Mersin 2013: Comodo - Siber Güvenlik ve Hacking - Samsun 2011: Microsoft Web Erişim Riskleri - İstanbul 2011: Bilişim Güvenliği Zirvesi - İstanbul Sertifikasyon ve Yarışma 2017: BTK (USOM) Siber Yıldız CTF 2014: TSE Sızma Testi Uzmanlığı (Sistem) 2014: TSE Sızma Testi Uzmanlığı (Web) 2014: Siber Meydan 2014 (CTF) 2009: Proje Tabanlı Beceri Yarışması, Samsun birinciliği, Karadeniz Bölgesi üçüncülüğü Son güncellenme tarihi : 10 Şubat 2017","tags":"pages","title":"Hakkımda"},{"url":"https://www.mustafa.com.tr/pages/contact.html","text":"E-posta: mustafa [@] altinkaynak [.] biz circletwitterbird circlegithubalt circlelinkedin","tags":"pages","title":"Contact"},{"url":"https://www.mustafa.com.tr/siber-guvenlik-ve-hacking-kitabi.html","text":"Yaklaşık bir seneyi aşkın süredir üzerinde çalıştığım \"Uygulamalı Siber Güvenlik ve Hacking Kitabı\" Akademik Bilişim 2017'in ilk gününde Abaküs Kitap standında satışa sunuldu. Nerelerden satın alabilirim? Abaküs Kitap Kitap Yurdu n11 TDK Kitap Store Kitap Avrupa Kitapta hangi konular yer alıyor? Siber Güvenliğe Giriş GNU/Linux Temelleri Forensic Kriptoloji Aktif/Pasif Bilgi Toplama Port ve Servis Taramaları Web Uygulama Güvenliği OWASP Boolean-based blind SQL Injection Error-based SQL Injection UNION-based SQL Injection Time-based SQL Injection Reflected XSS Stored XSS DOM XSS XSS BeEF XSS Keylogger Local/Remote File Include CSRF CRLF Injection HTTP Parameter Pollution (HPP) Application Logic XML Entity (XXE) Remote Command Execute (RCE) Sqlmap Burp Suite Metasploit Framework Msfencode, Msfpayload Msfvenom Windows, Linux Backdoor Android Backdoor Hydra, Medusa, Mimikatz Firewall/IDS VPN DDoS SYN, HTTP, UDP Flood DNS Man-in-the-middle ARP Spoof DNS Spoof DHCP Saldırıları WEP Cracking WPA/WPA2 Cracking Tersine Mühendislik Cracking Stack Buffer Overflow Fiziksel Güvenlik BadUSB Teensy Tavsiyeler ve çok daha fazlasını kitap içerisinde bulabilirsiniz.","tags":"Genel","title":"Siber Güvenlik ve Hacking Kitabı"},{"url":"https://www.mustafa.com.tr/btk-usom-siber-yildiz-yarismasi-cozumleri.html","text":"Siber Yıldız Yarışması nedir? Türkiye'de var olan Siber Güvenlik Uzmanlarının keşfedileceği, onları cesaretlendirip, onore edici ödüllerin de verileceği ülkemizin 2017 yılı Siber Yıldızlarının belirleneceği Siber Güvenlik Yarışmasıdır. Yarışmayı KırmızıBeyaz ekibi olarak başarıyla tamamladık. Takım arkadaşlarım Hakan ERYAVUZ , Besim ALTINOK ve Meryem AKDOĞAN 'ı kutluyorum. Resmi açıklamayı bekliyoruz. Bu sürede sizlerle çözümlediğimiz soruları paylaşmak istedik. Besim Altınok'un github hesabından diğer sorulara ulaşabilirsiniz. Sorular yazıldıkça içerik güncellenecektir. 2. Bakalım ne kadar iyisin? Bu soru basit bir SQL injection sorusuydu. Başta temel SQL injection ile ilerledik. Kullanıcı adı kısmına sayfanın altında yer alan ibareden hareketle Yonetici , parola kısmına ise '1 'or'='1 şeklinde yazdığımızda sayfa çıktısında \" giriş yaptın \" şeklinde ibare aldık. Artık bariz SQL injection olduğu ortada idi. Hedef uygulama üzerinde boolean ve time based olmak üzere iki farklı SQL injection zafiyeti tespit ettik. Bağlantımızın yavaş olması nedeniyle time based üzerinden sonuç alamayabilirdik. Bu yüzden boolean SQL injection tekniğiyle ilerledik. Sqlmap aracıyla yeni tanışanlar için basit şekilde anlatmak istiyorum. Aşağıdaki komut ile birlikte parola parametresini hedef alarak dbs parametresi sayesinde veritabanı listesini getirdik. sqlmap . py - u \"http://85.111.95.37/fc00914149de9f33c30cf0164ec4db95/index.php\" -- data = \"kullaniciadi=Yonetici&parola=\" - p parola -- risk = 3 -- level = 5 -- dbms = mysql -- dbs Bu komutta ise bir önceki komut ile elde ettiğimiz web2 adındaki veritabanında yer alan tüm tabloları getirdik. sqlmap . py - u \"http://85.111.95.37/fc00914149de9f33c30cf0164ec4db95/index.php\" -- data = \"kullaniciadi=Yonetici&parola=\" - p parola -- risk = 3 -- level = 5 -- dbms = mysql - D web2 -- tables Aşağıdaki komut ile birlikte bir önceki komutlar ile elde ettiğimiz \"web2\" ve \"kullanıcılar\" tablosunun dökümünü( --dump ) aldık. sqlmap . py - u \"http://85.111.95.37/fc00914149de9f33c30cf0164ec4db95/index.php\" -- data = \"kullaniciadi=Yonetici&parola=\" - p parola -- risk = 3 -- level = 5 -- dbms = mysql -- dbs -- random - agent - D web2 - T kullanicilar -- dump İlgili flag kullanıcılar tablosunda yer almaktaydı ve flag boolean tekniğiyle karşımıza geldi. FLAG: f4aa0edc033b9dfcc676c33420996789 3. Yetkili bir kullanıcı ile giriş yapman lazım. Bu sayfada ise bizi websitesi karşılıyor. Sayfa içerisinde gezinirken bir yandan da headerı kontrol ediyordum. Header içerisinde isAdmin=cfcd208495d565ef66e7dff9f98764da şeklinde tanımlanmış bir cookie bilgisine ulaştık. cfcd208495d565ef66e7dff9f98764da md5 değerini çözünce 0 olarak gördük. Yani isAdmin=md5(1) yapmamız durumunda hak yükseltebilirdik. isAdmin=c4ca4238a0b923820dcc509a6f75849b şeklinde isteklerimizi gönderdiğimizde bilgiler.php dosyasında flage ulaştık. 4. Şimdi de uygulamanın kullandığı veritabanı parolası lazım. Bu soruya giriş yaptığımızda \"404 NOT Found\" hata sayfası ile karşılaşılıyordu. Sayfanın kaynağını incelediğimiz de CSS ile gizlenmiş şekilde bir form yer alıyordu. Görünür hale getirdikten sonra \" admin \",\" admin \" ikisiyle içeri girdik. Bilet Satış Platformunda başlığında bir sayfaya yönlendirildik. Bu sayfada \" index.php?file=firmalar.php \", \" index.php?file=sitekullanimi.php \" gibi URL bilgilerini görünce LFI olduğunu doğrudan anladık. index.php?file=firmalar.php sayfası üzerinde almış olduğumuz /home/sites/siberyildiz/files/inc/pages/firmalar.php syntax error on line 11 hatası ise dizini tespit etmemize yardımcı oldu. Bulunduğumuz dizinin pages dizini olduğunu gördük. Genellikle web geliştirici veritabanı bağlantı bilgilerini \"includes\",\"inc\",\"db\" gibi klasörler altında \" ayar.php \",\" ayarlar.php \",\" connect.php \",\" conn.php \",\" db.php \" gibi dosya isimlerinde tutmaktadır. Bu teoriden yola çıkarak bir üst dizine çıkmamızı ve db.php dosyasını içeri çağıran URL ile birlikte index.php?file=../db.php kolayca flagi elde ettik. Kahraman Şehidimiz Ömer Halis DEMİR 'e Allah'dan rahmet diliyoruz. 11. Bu görev önünde iki seçenek var : başarılı olursun veya olamazsın? Bu soruya giriş yapıldığında \"nothing here\" şeklinde bir ibare karşılıyordu. Ne olabilir diye düşünürken robots.txt dosyasını görüntüledik. İçerisinde yer alan Disallow: cannotfindme bilgisi üzerine cannotfindme dizinine geçtik. Burada ufak bir giriş alanı gördük. Kullanıcı adı \"admin\" olarak giriş yaptığımızda, yeni bir alan ve form açıldı. Giriş yaptığımız yerde bizden komut çalıştırılması isteniyordu. http://www.hedef.com/?pass=sifre&cmd=ls şeklinde oluşan link üzerinde pass değişkenini brute force uygulamak CTF mantığımıza aykırı gelmişti. Kısa süre sonra array injection ile birlikte ?pass[]=&cmd=ls olarak dosyaları listelemeyi başardık. İlgili dizinde \"index.php\" , \"readme.txt\" ve \"try.html\" dosyalarının olduğunu gördüm. try.html dosyası içerisinde read file /tmp/isThatFlag.txt ifadesi yer alıyor fakat sistem ls harici komut çalıştırmamıza izin vermiyordu. Bunun üzerine /tmp altındaki isThatFlag.txt dosyasını okumak için new line yani bir alt satıra geç ifadesinin encode değeri olan %0a ifadesini kullandık. http://hedef.com/cannotfindme/?pass[]=&cmd=ls%0acat%20/tmp/isThatFlag.txt ile birlikte flagi elde ettik. 12. Yapabileceğine inancımız tam.? Bu soruda ise resimden göreceğiniz üzere iki adet bağlantı yer almaktadır. Ek olarak index.php?id=1 bağlantısı üzerinden dosya indirebileceğimiz söylenmektedir. Bağlantıya tıkladığımızda \"a.jpg\" isimli boş bir dosyanın indirildiğini görüyoruz. Muhtemelen aşağıdaki şekilde bir SQL sorgusu arka planda işlemektedir. select * from files where id = 1 Biz bunu şu şekilde yaparsak dosya indirebiliriz. select * from files where id =- 1 ' UNION 1 , ' / etc / passwd ' % 23 Bir UNION SQL injection kuralı gereği ilk sorguda kaç kolon dönüyorsa, ikinci sorguda aynı sayıda kolonun dönmesi gerekmektedir. Bu yüzden UNION'dan sonra 1 ifadesini yalnızca kolon olması adına ekledik. Biraz uğraşın ardında diğer sayfalarda yer alan SQL bağlantı hataları izlenimindeki ifadeler üzerinden \"users\" veritabanına girebilmek adına yedeklerine ulaşmak için /var/lib/mysql/ altından ilgili veritabanı ve tablo bilgilerini indirdik. /var/lib/mysql dizini altında veritabanları, kolonlar ve içerikleri yer almaktadır. select * from files where id =- 1 ' UNION 1 , ' / var / lib / mysql / users / login . MYD ' % 23 Elde ettiğimiz login.MYD dosyasını string ile okuduğumuzda giriş bilgilerini elde ettik. mustafaaltinkaynak : mustafaaltinkaynak$ strings login . MYD admin bu1Parolami ? Sence ? Elde ettiğimiz bu bilgiyi ikinci bağlantıda yer alan ?username=DENEME&password=deneme ile giriş yapabilirsiniz ibaresinin yer aldığı kısıma GET isteği şeklinde gönderdiğimizde flagi elde ettik.","tags":"Genel","title":"BTK (USOM) Siber Yıldız Yarışması Çözümleri"},{"url":"https://www.mustafa.com.tr/ufw-kurulumu-ve-yapilandirma.html","text":"UFW nedir? UFW yani Uncomplicated Firewall güvenlik duvarı yönetim aracıdır. Iptables güvenlik duvarı yapılandırmasını kolaylaştırmak için geliştirilen ufw, ipv4 veya v6 ile desteğiyle birlikte kullanıcıların işini epeyi kolaylaştırmaktadır. Varsayılan olarak UFW devre dışı olarak gelmektedir. UFW'yi konsol üzerinden yönetebileceğiniz gibi GUI desteği sayesinde konsol kullanmadan Gufw ile de yönetebilirsiniz. Ubuntu için varsayılan güvenlik duvarı yapılandırma aracıdır. UFW kurulumu UFW ubuntu üzerinde varsayılan geldiğinden dolayı farklı bir işletim sistemi kuruyorsanız aşağıdaki adımı izleyebilirsiniz. mustafa @ altinkaynak :/ # apt - get install ufw Kurulum işleminin ardından aşağıdaki komut ile birlikte versiyon kontrolü sağlayabilirsiniz. mustafa @ altinkaynak :/ # ufw version ÖNEMLİ: Eğer ki ev kullanıcı iseniz UFW sizler için varsayılan bir profil ile birlikte sisteminize dahil olmaktadır. Kısacası, ev kullanıcıları için istisnalar dışında tüm gelen istekler reddedilmektedir. UFW yönetimi UFW'yi etkinleştirmek yada pasifleştirmek için aşağıdaki komutu kullanabilirsiniz. mustafa @ altinkaynak :/ # ufw enable Firewall is active and enabled on system startup mustafa @ altinkaynak :/ # ufw disable Firewall stopped and disabled on system startup Mevcut UFW'ye ait kurallar dizisini görmek için aşağıdaki komutu kullanabilirsiniz. mustafa @ altinkaynak :/ # ufw status verbose Status: active Logging: on ( full ) Default: deny ( incoming ), allow ( outgoing ), disabled ( routed ) New profiles : skip Henüz bir kural tanımlamadığımız kurallar dizisi görünmemektedir. Ancak UFW'nin mevcut durumuna ilişkin bilgi sahibi olabileceğimiz bilgiler yer almaktadır. Firewall'ın durumu, loglama hassasiyeti, ön tanımlı davranışını bu çıktı da yer almaktadır. Kural içerikleri \"/etc/ufw\" altında \".rules\" uzantısı ile biten dosyalarda yer almaktadır. Kural oluşturma UFW üzerinde iki farklı davranış allow, deny belirleyebilirsiniz. Allow ile izin verebilir, deny ile gelen istekleri reddedebilirsiniz. Allow içeren kurallar aşağıdaki şekilde tanımlanabilir. ufw allow < port >/< optional : protocol > 53.port üzerine gelen TCP ve UDP bağlantılarına izin verelim. mustafa @ altinkaynak :/ # ufw allow 53 Yalnızca TCP üzerinden gelen bağlantılara izin vermek için, mustafa @ altinkaynak :/ # ufw allow 53 / tcp Yalnızca UDP üzerinden gelen bağlantılara izin vermek için, mustafa @ altinkaynak :/ # ufw allow 53 / tcp Deny içeren kurallar aşağıdaki şekilde tanımlanabilir. ufw deny < port >/< optional : protocol > 53.port üzerine gelen TCP ve UDP bağlantılarını engelleyelim. mustafa @ altinkaynak :/ # ufw deny 53 Yalnızca TCP üzerinden gelen bağlantıları engellemek için, mustafa @ altinkaynak :/ # ufw deny 53 / tcp Yalnızca UDP üzerinden gelen bağlantıları engellemek için, mustafa @ altinkaynak :/ # ufw deny 53 / udp Belirli Subnet'e izin verelim. mustafa @ altinkaynak :/ # ufw allow from 192.168.1.0 / 24 Belirlenmiş bir IP adresine erişim izni verelim. mustafa @ altinkaynak :/ # ufw allow from 10.50.1.55 Belirlenmiş bir IP adresine yalnızca bir port için izin verelim. mustafa @ altinkaynak :/ # ufw allow from 10.50.1.55 to any port 22 RFC1918 adresleri yani 10.0.0.0/8, 172.16.0.0/12, 169.254.0.0/16, 192.168.0.0/16 olarak belirlenen adreslere izin verelim. mustafa @ altinkaynak :/ # ufw allow from 10.0.0.0 / 8 Rule added mustafa @ altinkaynak :/ # ufw allow from 172.16.0.0 / 12 Rule added mustafa @ altinkaynak :/ # ufw allow from 192.168.0.0 / 16 Rule added Bazı durumlarda kuralların birbirlerini bastırdığı durumlar olabilir. Örneğin: SSH bağlantılarını tümüyle kapatan bir kural eklediniz. Akabinde de spesifik bir adres için SSH izni verdiniz. Bu durumda ilk eklediğiniz kural gerçekleşecektir ve spesifik IP adresi bağlantı gerçekleştiremeyecektir. Bu durumda araya kural eklemesi yapabilirsiniz. mustafa @ altinkaynak :/ # ufw insert 1 allow from 10.50.1.55 to any port 22 Rule inserted Belirli bir IP adresi veya subnet için protokol sınırlaması getirelim. mustafa @ altinkaynak :/ # ufw allow from 10.50.1.55 to any port 22 proto tcp Rule added mustafa @ altinkaynak :/ # ufw allow from 192.168.0.0 / 16 to any port 22 proto tcp Rule added Kural kaldırma UFW üzerinde kural kaldırmak için kural oluşturma sırasında yazmış olduğunuz koda delete eklemeniz yeterlidir. 80.porta gelen bağlantıları engellemek için, mustafa@altinkaynak:/# ufw deny 80/tcp Belirlenen bu kuralı silmek için, mustafa @ altinkaynak :/ # ufw delete deny 53 / udp Yada tüm kurallar içerisinden belirlemiş olduğunuzu silmek istiyorsanız öncelikle aşağıdaki komutla kuralları numaralandırılmış halde listeleyin, ardından silmek istediğiniz kuralın numarasını ufw delete komutuna vermeniz yeterlidir. mustafa @ altinkaynak :/ # ufw status numbered Status: active To Action From -- ------ ---- [ 1 ] 80 / tcp DENY IN Anywhere [ 2 ] 80 / tcp ( v6 ) DENY IN Anywhere ( v6 ) mustafa @ altinkaynak :/ # ufw delete 1 Deleting: deny 80 / tcp Proceed with operation ( y | n ) ? y Rule deleted Servisler için kural yazma UFW /etc/services dosyasını da okuyabildiği için hizmet adına göre de izin verebilir veya reddedebilirsiniz. Servislerin listesini görmek için \"/etc/services\" dosyasına göz atabilirsiniz. Servis ismiyle bağlantıya izin verilen kurallar aşağıdaki şekilde tanımlanabilir. ufw allow < service name > SSH servisine bağlantılara izin vermek için, mustafa @ altinkaynak :/ # ufw allow ssh Rule added Rule added ( v6 ) Servis ismiyle bağlantının reddedildiği kurallar aşağıdaki şekilde tanımlanabilir. ufw deny < service name > SSH servisine bağlantıları reddetmek için, mustafa @ altinkaynak :/ # ufw deny ssh Rule added Rule added ( v6 ) Loglama UFW loglama için farklı bir değer belirtilmedikçe \"low\" yani düşük seviye loglama işlemi yapmaktadır. Loglama konusunda hassas davranmak istiyorsanız aşağıdaki komutu 'off', 'low', 'medium', 'high' ve 'full' değerleriyle birlikte kullanabilirsiniz. Log kaydetme seviyeleri yükseldikçe daha fazla çıktı üreterek, yoğunluğunuza göre diskinizi hızla doldurabilir. Production ortamlarda yapılacak olan seviye belirlemelerinde bunu göz önünde bulundurmalısınız. Loglama işlemini devre dışı bırakmak için, mustafa @ altinkaynak :/ # ufw logging off Logging disabled En yüksek düzeyde loglama gerçekleştirmek için, mustafa @ altinkaynak :/ # ufw logging full Logging enabled Loglama işlemini tamamiyle devre dışı bırakmak için, mustafa @ altinkaynak :/ # ufw logging off Logging disabled Bir sonraki yazımda görüşmek dileğiyle.","tags":"Sistem Yöneticiliği","title":"UFW Kurulumu ve Yapılandırma"},{"url":"https://www.mustafa.com.tr/haproxy-kurulumu-ve-yapilandirma.html","text":"HAProxy nedir? HAProxy (High Availability Proxy), bir yük dengeleme görev yöneticisidir. Birçok servis için yük dengeleme, yüksek erişilebilirlik ve proxy gibi hizmetleri ücretsiz, güvenli olarak sunmaktadır. Stabil versiyonu 1.6'dır. Bu yazı da ise Ubuntu üzerine HAProxy 1.4.24 kurulumu gerçekleştirerek aşağıda yer alan yapıyı oluşturacağız. HAProxy sunucusu: 192.168.1.200 Webserver 1: 192.168.1.201 Webserver 2: 192.168.1.202 Tüm sunuculara web server kurulumunu gerçekleştirdim. HAProxy kurulumu Ubuntu deposunda tanımlı olduğundan dolayı direkt apt-get ile kurabilirsiniz. mustafa @ altinkaynak :/ # apt - get install haproxy Kurulum işleminin ardından aşağıdaki komut ile birlikte versiyon kontrolü sağlayabilirsiniz. mustafa @ altinkaynak :/ # haproxy - v HA - Proxy version 1.4.24 2013 / 06 / 17 Copyright 2000 - 2013 Willy Tarreau < w @ 1 wt . eu > HAProxy'i etkinleştirmek için /etc/default/haproxy dosyasında yer alan ENABLED değerini 1 olarak değiştirmeniz gerekmektedir. ENABLED = 1 Artık HAProxy servisi için etkinlikler geldi. mustafa @ altinkaynak :/ # service haproxy Usage: / etc / init . d / haproxy { start | stop | reload | restart | status } HAProxy yapılandırma Herşeye başlamadan önce mevcut HAProxy konfigurasyon dosyasını yedekleyelim. mv / etc / haproxy / haproxy . cfg {,. original } Artık haproxy.cfg adında yeni bir konfigurasyon dosyası oluşturarak burada işlem gerçekleştirelim. global log / dev / log local0 log 127.0.0.1 local1 notice maxconn 4096 user haproxy group haproxy daemon defaults log global mode http option httplog option dontlognull retries 3 option redispatch maxconn 2000 contimeout 5000 clitimeout 50000 srvtimeout 50000 listen altinkaynak 127.0.0.1 : 80 mode http stats enable stats uri / haproxy ? stats balance roundrobin option httpclose option forwardfor server webserver01 192.168.1.201 : 80 check server webserver02 192.168.1.202 : 80 check Bu sürüm için geçerli konfigurasyon açıklamasına buradan ulaşabilirsiniz. Şimdi HAProxy dashboard sayfamıza göz atalım. Aşağıdaki göreceğiz üzere tüm servislerimiz yerlerini almış ve UP/DOWN durumları zamansal olarak gösterilmiştir. Servisler üzerinde açılan session sayısını da görebilmekteyiz. Sunucuların up/down durumlarında e-posta bildirimi almak isteyebilirsiniz. O zaman güzel bir haber vereyim. HAProxy 1.6 sürümünde bildirim desteği gelmiştir. Ancak 1.4 sürümünde olmadığından dolayı bu yazıda yer veremiyorum. HAProxy'in bize sunmuş olduğu yük dengelemeyi de test edelim. Artık tüm trafiği HAProxy sunucusu üzerine (192.168.1.200) üzerine yönlendiriyoruz. Ben farkı anlayabilmek açısından giriş sayfalarına hangi sunucuya bağlantı yaptığımı yazdırdım. Sonuç olarak HAProxy en uygun olan sunucuya beni yönlendirdi.","tags":"Sistem Yöneticiliği","title":"HAProxy Kurulumu ve Yapılandırma"},{"url":"https://www.mustafa.com.tr/nagios-uzak-sunucu-ekleme.html","text":"Nagios ağ üzerinde bulunan sistemleri monitör etmek için kullanılan bir yazılım olduğunu bir önceki yazılarımda ifade etmiştim. Şimdi nagios üzerine uzak bir sunucuyu kontrol etmek için görev (host, servis) tanımlayalım. Bu yazı da www.mustafa.com.tr adresi için HTTP ve SSH servislerini belirli zaman aralıklarında kontrol etmesini sağlayacağım. Host ve servis tanımlama /etc/nagios3/conf.d dizini altına giderek hostadi_nagios2.cfg adında bir dosya oluşturalım. define host { use generic - host host_name mustafa . com . tr alias mustafa . com . tr } define service { use generic - service ; Name of service template to use host_name mustafa . com . tr service_description HTTP normal_check_interval 2 retry_check_interval 1 flap_detection_enabled 0 max_check_attempts 2 check_command check_http notifications_enabled 1 } define service { use generic - service host_name mustafa . com . tr service_description SSH check_command check_ssh notifications_enabled 1 } Akabinde aşağıdaki komutu çalıştırarak config dosyasının hata kontrolünü sağlayalım. sudo nagios3 - v / etc / nagios3 / nagios . cfg | less Nagios'u yeniden başlatalım. sudo service nagios3 reload Host nagios paneline eklenmiş gözüküyor.","tags":"Sistem Yöneticiliği","title":"Nagios Uzak Sunucu Ekleme"},{"url":"https://www.mustafa.com.tr/slack-fail2ban-entegrasyonu.html","text":"Brute Force Nedir? Saldırganların sıklıkla tercih ettikleri tekniklerden biri de Brute Force adı verilen kaba kuvvet saldırılarıdır. Brute force bir program yardımıyla yapılabileceği gibi el ile de yapılabilir. Brute force saldırılarında kullanıcı adı ve parola bilgisi teker teker denenir. Bu saldırıda başarılı olunabilmesi için en çok kullanılan parola dizilimleri yani sözlük denilen listeler kullanılır. Ne kadar geniş bir sözlük varsa başarıya ulaşma imkanı da o kadar yüksek olur. Uygulamalar brute force saldırılarına yönelik çeşitli aksiyonlar almışlardır. Bazı uygulamalar çok sayıda giriş yapıldığında captcha ile giriş istemekte, bazı uygulamalar ise belirli süre o kullanıcıya ait hesabı kapatmaktadır. Fail2Ban Nedir? Fail2ban sunucu sistemlerinde servislere ait log kayıtlarının takip edilerek gerektiği durumlarda bu kişilere karşı aksiyon almayı sağlar. Bu kişilere yönelik sizin belirlediğiniz süre kadar sisteme girişlerini yasaklar. Fail2ban iptables firewall'a ilgili kuralı dinamik olarak girmektedir. Ek olarak fail2ban tcpwrapper'la da çalışabilmektedir. Şu sıralar epeyi Slack ile haşır neşir olmaya ve gittikçe sevmeye başladım. Şimdi fail2ban'ın almış olduğu aksiyonlardan anında haberdar olabilmek için Slack ile entegrasyon edelim. NOT: Bu tarz durumlar için e-posta kullanmayı pek sevmediğimden dolayı, e-posta ile notification almak istemiyorum. Tercihim bu yüzden Slack'den yana. Fail2ban Slack Entegrasyonu Fail2ban uygulamasına ait yapılandırma ayarları /etc/fail2ban/jail.conf dosyasında tutulmaktadır. Ancak custom (özelleştirilmiş) yapılandırma ihtiyaçlarında bu dosyanın bir kopyası üzerinden devam edilmesi önerilir. cp / etc / fail2ban / jail . conf / etc / fail2ban / jail . local Artık değişikliklerimizi jail.local dosyası üzerinden gerçekleştireceğiz. Slack için action durumunu ayarlayalım. action_with_slack_notification = % ( banaction ) s [ name =% ( __name__ ) s , port = \"%(port)s\" , protocol = \"%(protocol)s\" , chain = \"%(chain)s\" ] slack [ name =% ( __name__ ) s , protocol = \"%(protocol)s\" ] # Choose default action. To change, just override value of 'action' with the # interpolation to the chosen action shortcut (e.g. action_mw, action_mwl, etc) in jail.local # globally (section [DEFAULT]) or per specific section action = % ( action_with_slack_notification ) s Slack için bildirimlerde kullanacağımız betiği oluşturmak için ilgili dizine gidelim. cd / etc / fail2ban / action . d Şimdi slack bildirimleri için slack-notify.sh adında betiğimizi oluşturalım. # !/bin/bash # Dosya: /etc/fail2ban/action.d/slack-notify.sh MESSAGE=$1 HOOK_URL={HOOK_URL} # https://hooks.slack.com/services/1111111/1111111111111 HOST=$(hostname) CHANNEL=\"#alerts\" # Hangi kanala gönderim yapılacak USERNAME=\"fail2ban\" # Hangi kullanıcı adıyla gönderim yapılacak ICON=\":bangbang:\" # Mesajlarda kullanılacak icon -> http://www.webpagefx.com/tools/emoji-cheat-sheet/ if [ \"$#\" -ge 2 ]; then IP=$2 # İsteğin hangi ülkeden geldiği COUNTRY=$(curl ipinfo.io/ ${ IP } /country) COUNTRY=$(echo \" $COUNTRY \" | tr -s '[:upper:]' '[:lower:]') # Ülkeye uygun emoji setleniyor. COUNTRY=\":flag- $COUNTRY :\" MESSAGE=\" ${ MESSAGE / _country_ / $ COUNTRY } \" fi # Curl isteği gerçekleştiriyoruz. curl -X POST --data-urlencode \"payload={\\\"channel\\\": \\\" ${ CHANNEL } \\\", \\\"username\\\": \\\" ${ USERNAME } \\\", \\\"text\\\": \\\"[* ${ HOST } *] ${ MESSAGE } \\\", \\\"icon_emoji\\\": \\\" ${ ICON } \\\"$ exit 0 Bildirim betiğimiz hazır. Şimdi hangi durumlarda çalışması gerektiğini belirliyoruz. # Dosya : / etc / fail2ban / action.d / slack.conf [ Definition ] actioncheck= actionstart = /bin/bash /etc/fail2ban/action.d/slack-notify.sh \"The jail <name> has been started successfully.\" > /dev/null 2> & 1 actionstop = /bin/bash /etc/fail2ban/action.d/slack-notify.sh \"The jail <name> has been stopped.\" > /dev/null 2> & 1 actionban = /bin/bash /etc/fail2ban/action.d/slack-notify.sh \"Banned _country_ <ip> in the jail <name> after <failures> attempts\" \" <ip> \" > /dev/null 2> & 1 actionunban = /bin/bash /etc/fail2ban/action.d/slack-notify.sh \"Unbanned _country_ <ip> in the jail <name> \" \" <ip> \" > /dev/null 2> & 1 # Default name of the chain # name = default Artık servis başladığında, durduğunda, bir kullanıcı sistemden atıldığı ve yasaklamasının kaldırıldığı durumda bildirim gelecektir.","tags":"Sistem Yöneticiliği","title":"[SLACK] Fail2ban Entegrasyonu"},{"url":"https://www.mustafa.com.tr/slack-nagios-entegrasyonu.html","text":"Nagios ağ üzerinde bulunan sistemleri monitör etmek için kullanılan bir yazılımdır. Yazılım sayesinde tüm aktif cihazlarını sizlere sunmuş olduğu arayüz üzerinden monitör edebilirsiniz. Nagios ile birlikte makinalara farklı görev tanımları gerçekleştirebilir ve durum maili alabilirsiniz. Buraya tıklayarak Nagios'a ulaşabilirsiniz. Slack Nagios Entegrasyonu https://my.slack.com/services/new/nagios adresinde yer alan \"Add Nagios integration\" kısmı içerisinde yer alan Setup Instructions başlığı altında kurulum talimatlarına ulaşabilirsiniz. Sizler için takımınıza ait kanal ismi ve token bilgisi dinamik olarak üretilecektir. wget https : //raw.github.com/tinyspeck/services-examples/master/nagios.pl cp nagios . pl / usr / local / bin / slack_nagios . pl chmod 755 / usr / local / bin / slack_nagios . pl slack_nagios.pl dosyası içerisinde bizlere özel teamname ve token bilgisini düzenleyelim. my $opt_domain = \"teamname.slack.com\" ; # Your team's domain my $opt_token = \"token\" ; # The token from your Nagios services page Nagios bildirimlerin kimlere gönderileceği dair yapılandırma ayarlarını /etc/nagios3/conf.d/contacts_nagios2.cfg dosyasında tutmaktadır. define contact { contact_name slack alias Slack service_notification_period 24 x7 host_notification_period 24 x7 service_notification_options w , u , c , r host_notification_options d , r service_notification_commands notify - service - by - slack host_notification_commands notify - host - by - slack } Yukarıdaki contact tanımlaması ile birlikte yeni bir bildirim türü belirledik. Service Notification Options parametreleri Parametre Açıklama w Warning durumlarında bildirim gönderir. u Unknown durumlarında bildirim gönderir. c Kritik durumlarda bildirim gönderir. r Servisin tekrar ayağa kalkma durumunda bildirim gönderir. f Servisin start/stop durum analizini gönderir. s Zamanlanmış aralıklarda bildirim gönderir. Host Notification Options parametreleri Parametre Açıklama d Hostun down olması durumunda bildirim gönderir. u Hostun UNREACHABLE olduğu durumlarda bildirim gönderir. r Hostun tekrar ayağa kalkma durumunda bildirim gönderir. f Hostun start/stop durum analizini gönderir. s Zamanlanmış aralıklarda bildirim gönderir. Nagios bildirim komutlarını tanımlayalım Contact profilini tanımlarken service_notification_commands ve host_notification_commands parametrelerini kullanmıştım. Şimdi commands.cfg dosyası içerisinde bu komutlarını tanımlayalım. Bu dosyayı \"/etc/nagios3/commands.cfg\" adresinden ulaşabilirsiniz. define command { command_name notify - service - by - slack command_line / usr / local / bin / slack_nagios . pl - field slack_channel = # nagios - field HOSTALIAS = \"$HOSTNAME$\" - field SERVICEDESC = \"$SERVICEDESC$\" - field SERVICESTATE = \"$SERVICESTATE$\" - field SERVICEOUTPUT = \"$SERVICEOUTPUT$\" - field NOTIFICATIONTYPE = \"$NOTIFICATIONTYPE$\" } define command { command_name notify - host - by - slack command_line / usr / local / bin / slack_nagios . pl - field slack_channel = # nagios - field HOSTALIAS = \"$HOSTNAME$\" - field HOSTSTATE = \"$HOSTSTATE$\" - field HOSTOUTPUT = \"$HOSTOUTPUT$\" - field NOTIFICATIONTYPE = \"$NOTIFICATIONTYPE$\" } Ben Nagios üzerine MySQL server kontrolünü de eklemiştim. Şimdi MySQL servisimizi durduralım. 18:34:36'da MySQL servisi durdurdum. 18:35:19'da da Nagios MySQL servisine erişemediğine dair bildirimi göndermiş. Aynı esnada cep telefonuma da bildirim geldi.","tags":"Sistem Yöneticiliği","title":"[SLACK] Nagios Entegrasyonu"},{"url":"https://www.mustafa.com.tr/slack-ssh-girislerini-bildirim-olarak-almak.html","text":"Merhabalar. Bu yazımızda daha çok geliştirici ekiplerinin kullandığı ekip içi yazışma ortamı sağlayan Slack ile ilgili çalışma gerçekleştireceğiz. Artık ekip içi yazışmalarınızı, iş atamalarınızı (busybot) Slack üzerinden yaptığınıza göre fazlalıklardan kurtulmak isteyebilirsiniz. Şahsen ben çok fazla ortam kullanmayı tercih etmek yerine, tek yerden bir dashboard mantığında herşeyi görebilmek isterim. Kısa bir girizgahından ardından giriş yapalım. Slack'de çoğu uygulama gibi webhook yapısına uygun tasarlanmıştır. Webhook farklı uygulamaların birbirleri ile entegrasyon sağlayabilmeleri için Uygulama içerisinde oluşan event'leri HTTP üzerinden JSON Payload'ları ile kendilerine subscribe olan diğer uygulamaları tetiklemesidir. Tabii bu işlemi yapabilmeniz için webhook izinlerini sağlamanız gerekmektedir. Slack için token oluşturalım. Buraya tıklayarak Integration Settings alanından yapılandırma ayarlarına ulaşabilirsiniz. Post to Channel: Gönderim yapacağınız kanal Webhook URL : Kanalı seçmeniz ardından bu URL dinamik olarak oluşacaktır. Bu URL'yi sonra ki aşamalarda kullanacağımızdan dolayı saklamanız gerekmektedir. Descriptive Label: Dilerseniz opsiyonel olarak açıklama etiketi girebilirsiniz. Customize Name: Gelen bildirimlerde yer alan kullanıcı adını seçebilirsiniz. Customize Icon: Gelen bildirimlerde yer alan iconu değiştirebilirsiniz. Preview Message: Bu alandan da gelecek bildirimi önizleme olarak görebilirsiniz. Ayarları \"Save Settings\" butonu ile birlikte kaydediyoruz. SSH ile yapılan girişlerde bildirim gelmesini sağlayalım. /etc/profile dosyasını editör ile açtıktan sonra en alt kısmına aşağıdaki kod blogunu ekleyebilirsiniz. \"WEBHOOK_URL\" alanını yukarıda saklamanızı istediğim alanla değiştirmeyi unutmayınız. if [ -n \" $SSH_CLIENT \" ]; then TEXT=\"$(date): ssh login to ${ USER } @$(hostname -f)\" TEXT=\" $TEXT from $(echo $SSH_CLIENT |awk '{print $1}')\" curl -X POST \\ --data-urlencode \"payload={\\\"username\\\": \\\"SSH Login Alerts\\\", \\\"text\\\": \\\" ${ TEXT } \\\"}\" \\ WEBHOOK_URL & >/dev/null & fi Yukarıdaki kod blogunu açıklamak gerekirse, sadece SSH işlemlerinde çalışacak şekilde ayarlanmıştır. date parametresinde zaman damgası, $USER bağlantıyı gerçekleştiren kullanıcı, $hostname ise bağlantı yapılan makina adını içerir. $SSH_CLIENT ise bağlantıyı gerçekleştiren kullanıcının IP adresini içerir ve bu AWK ile sadeleştirilmiştir. Akabinde curl ile birlikte POST isteği gerçekleştiriyoruz. Curl istekleri sonrasında response değerlerinin ekrana yazdırılmaması için /dev/null değeri kullandım. Böylece ssh yapan kullanıcı hiçbir şekilde çıktı göremeyecektir. Kendim Slack uygulamasını mobilde de kullandığımdan dolayı bildirimler cep telefonuma da direkt ulaşmaktadır. Hepsi bu kadar.","tags":"Sistem Yöneticiliği","title":"[SLACK] SSH Girişlerini Bildirim Olarak Almak"},{"url":"https://www.mustafa.com.tr/vsftpd-kurulumu-ve-yapilandirma.html","text":"Yazımıza başlamadan önemli bir hatırlatmak isterim. FTP Protokolü cleartext trafik içermesi nedeniyle güvenli değildir. Bu yüzden SFTP protokolünü kullanmanızı öneririm. Kurulum Vsftpd server Ubuntu'nun default repolarından erişilebilmektedir. Ek olarak bir kaynak belirtmenize gerek yoktur. sudo apt - get install vsftpd Yapılandırma Vsftpd kurulumu ardından etc/vsftpd.conf dosyası içerisinde yapılandırma ayarları bulunmaktadır. Bu dosya içerisinde aşağıdaki değişiklikleri yapmanızı öneririm. FTP için anonymous bağlantı gerçekleştirmelerini kapatmak için aşağıdaki değeri varsa yorum satırından çıkartıp, \"NO\" olarak belirtiyoruz. anonymous_enable = NO Sunucu üzerinde yer alan kullanıcıların FTP'ye bağlanabilmelerini sağlamaları amacıyla aşağıdaki değeri varsa yorum satırından çıkartıp, \"YES\" olarak belirtiyoruz. local_enable = YES Kullanıcıların dosyalar üzerinde yazma işlemi yapabilmelerini sağlamaları amacıyla aşağıdaki değeri \"YES\" olarak belirtiyoruz. write_enable = YES Kullanıcıların home dizinlerine erişim hakkı vermek amacıyla aşağıdaki değeri \"YES\" olarak belirtiyoruz. chroot_local_user = YES Bu dosyayı kaydedip, çıkıyoruz. FTP Kullanıcı Hesabı Oluşturma Kullanıcı oluşturalım. sudo adduser ftpkullanicisi Kullanıcıyı oluşturduktan sonra, bu kullanıcıya ait dizin için root sahipliği verelim. sudo chown root : root / home / ftpkullanicisi Şimdi ise kullanıcıya dosyalarını gönderebileceği bir klasör oluşturalım ve bu kullanıcıya erişim hakkı verelim. sudo mkdir / home / ftpkullanicisi / dosyalar sudo chown ftpuser : ftpuser / home / ftpkullanicisi / files Vsftpd'yi yeniden başlatalım. sudo service vsftpd restart Tüm işlem bu kadar.","tags":"Sistem Yöneticiliği","title":"VSFTPD Kurulumu ve Yapılandırma"},{"url":"https://www.mustafa.com.tr/public-private-ile-ssh-baglantisi-saglama.html","text":"Bu yazımızda public/private ikilisi ile birlikte SSH bağlantısı sağlamayı akabinde ise sunucu üzerinde clear parola girilmesini yani pub/private ikilileri olmadan bağlantı sağlanamamasını gerçekleştireceğiz. Openssh-server kurulu değilse öncelikle olarak kurulumunu gerçekleştirin. sudo apt - get install openssh - server Client bilgisayar üzerinde anahtarlarınızı aşağıdaki komut ile birlikte oluşturalım. sudo ssh - keygen - t rsa root/.ssh dizini altına id_rsa ve id_rsa.pub dosyaları oluşturulmuş olacaktır. id_rsa.pub dosyanız uzantısından da anlaşılacağı üzere public key dosyanızdır. id_rsa ise iyi korunaklı saklamanız gereken private key dosyanızdır. Artık public anahtarımızı bağlantı yapacağımız sunucuya gönderelim. cat ~/ . ssh / id_rsa . pub | ssh root @ ip ' umask 077 ; cat >> . ssh / authorized_keys ' Client bilgisayarda artık aşağıdaki komut ile birlikte uzak sunucuya parola gerektirmeksizin bağlantı yapabilirsiniz. ssh uzaksunucu_ip Artık public/private ikilisi ile birlikte bağlantı yaptığımıza göre uzak sunucu üzerinde parola ile girişleri kapatabiliriz. Bunun için /etc/ssh/sshd_config kısmında aşağıdaki satırı bularak, # Change to no to disable tunnelled clear text passwords #PasswordAuthentication yes bununla değiştiriniz. # Change to no to disable tunnelled clear text passwords PasswordAuthentication no service ssh restart","tags":"Sistem Yöneticiliği","title":"Public / Private ile SSH Bağlantısı Sağlama"}]}